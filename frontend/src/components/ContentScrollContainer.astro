---
import DynamicComponent from './DynamicComponent.astro'
import Image from './Image.astro'
import { IMAGE_QUALITY } from '../lib/sanityImage'
import { stegaClean } from '@sanity/client/stega'

interface Props {
  title?: string
  items?: any[]
  showScrollbar?: boolean
  className?: string
  _key?: string
  _type?: string
}

const {
  title,
  items: rawItems,
  showScrollbar = false,
  className = '',
  _key,
  _type,
} = Astro.props

// Ensure items is always an array (handles null from Sanity)
const items = rawItems ?? []

// CSS classes
const scrollbarClass = showScrollbar ? '' : 'hide-scrollbar'

// Sanity Visual Editing attributes
const sanityAttributes = _key ? { 'data-sanity': `${_type}.${_key}` } : {}
---

<section class={`content-scroll-container ${scrollbarClass} ${className}`} {...sanityAttributes}>
  {title && <h2 class="scroll-container-title">{title}</h2>}

  <ul class="scroll-list scroll-container scroll-container--always scroll-container--content scroll-container--hide-scrollbar">
    {items.map((item) => {
      if (!item) return null

      // Handle imageComponent items with inline rendering
      if (item._type === 'imageComponent' && item.image) {
        const imageSource = item.image
        const imageAlt = stegaClean(item.alt || '')

        return (
          <li class="scroll-item">
            {imageSource ? (
              <Image
                image={imageSource}
                alt={imageAlt}
                size="small"
                aspectRatio="4:5"
                loading="lazy"
                quality={IMAGE_QUALITY.CARD}
                className="scroll-image"
              />
            ) : (
              <div class="image-placeholder">
                <span>Bilde ikke tilgjengelig</span>
              </div>
            )}
          </li>
        )
      }

      // Handle other component types with DynamicComponent
      return (
        <li class="scroll-item">
          <DynamicComponent block={item} />
        </li>
      )
    })}
  </ul>
</section>

<style>
  .content-scroll-container {
    container-type: inline-size;
    padding-block: var(--space-5);
  }

  .scroll-container-title {
    font-size: var(--step-3);
    font-weight: 600;
    margin-block-end: var(--space-m-l); /* Fluid 16px â†’ 30px */
  }

  /* Scroll list - behavior from scroll-containers.css */
  .scroll-list {
    --scroll-padding: 0; /* Remove left padding - wrapper handles margins */
    scroll-padding-inline: 0;
    padding-inline: 0;
    align-items: flex-start; /* Parent controls alignment - force top alignment */
    list-style: none;
    margin: 0;
    padding-block: var(--space-xs) var(--space-m);
  }

  .scroll-item {
    /* Match composer card sizing - fluid width, fixed aspect ratio */
    width: clamp(300px, 35vw, 320px);
    aspect-ratio: 4 / 5;
    overflow: hidden;
    position: relative;
  }

  /* All children fill the scroll-item completely */
  .scroll-item > :global(*) {
    margin: 0;
    width: 100%;
    height: 100%;
  }

  /* Hide image captions in scroll context - image fills entire card */
  .scroll-item :global(.image-caption) {
    display: none;
  }

  /* Override Image component constraints to fill scroll card */
  .scroll-item :global(.image-container) {
    width: 100%;
    height: 100%;
    margin: 0;
  }

  .scroll-item :global(.image) {
    width: 100%;
    height: 100%;
    max-height: none;
  }

  /* Image placeholder styling */
  .image-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    background: #f5f5f5;
    border: 2px dashed #ddd;
    color: #666;
  }

  /* Note: Spacing (margin, gap, padding) uses fluid tokens and adjusts automatically */

  /* Accessibility */
  .scroll-item:focus-within {
    outline: 2px solid #0066cc;
    outline-offset: 2px;
  }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .scroll-list.scroll-container {
      scroll-behavior: auto;
    }
  }
</style> 