---
import { PortableText } from 'astro-portabletext';

interface Props {
  value?: any[];
  content?: any[];
  className?: string;
  semantic?: 'auto' | 'div' | 'section' | 'article';
}

const { value, content, className = '', semantic = 'auto' } = Astro.props;

// Håndter både 'value' og 'content' props for kompatibilitet
const contentToRender = value || content || [];

// Smart context detection for semantic elements
function detectSemanticElement(semanticProp: string): string {
  if (semanticProp !== 'auto') {
    return semanticProp;
  }

  // Heuristic detection basert på hvor komponenten brukes
  // Hvis innholdet har overskrifter (h2-h6), er det sannsynligvis selvstendig innhold
  const hasHeadings = contentToRender.some((block: any) =>
    block.style && ['h2', 'h3', 'h4', 'h5', 'h6'].includes(block.style)
  );

  // Hvis innholdet er langt (mer enn 3 blokker), er det sannsynligvis selvstendig
  const isSubstantialContent = contentToRender.length > 3;

  // Hvis det har overskrifter eller er substansielt innhold, bruk <section>
  if (hasHeadings || isSubstantialContent) {
    return 'section';
  }

  // Ellers, bruk <div> for fragmenter
  return 'div';
}

const semanticElement = detectSemanticElement(semantic);

// Custom components for PortableText - følger Sanity's anbefalte struktur
const components = {
  types: {
    // Custom types kan legges til her
  },
  marks: {
    // Custom marks hvis nødvendig
  },
  block: {
    // Custom block rendering hvis nødvendig
  }
};
---

{semanticElement === 'section' ? (
  <section class={`portable-text content-narrow ${className}`}>
    {contentToRender && contentToRender.length > 0 && (
      <PortableText value={contentToRender} components={components} />
    )}
  </section>
) : semanticElement === 'article' ? (
  <article class={`portable-text content-narrow ${className}`}>
    {contentToRender && contentToRender.length > 0 && (
      <PortableText value={contentToRender} components={components} />
    )}
  </article>
) : (
  <div class={`portable-text content-narrow ${className}`}>
    {contentToRender && contentToRender.length > 0 && (
      <PortableText value={contentToRender} components={components} />
    )}
  </div>
)}

<style>
  .portable-text {
    line-height: 1.6;
  }
  
  .portable-text h2 {
    /* Aligned with base.css: --step-3 (31-35px responsive) */
    font-size: var(--step-3);
    font-weight: 600;
    margin-block: var(--space-l) var(--space-m); /* Fluid spacing */
  }

  .portable-text h3 {
    /* Aligned with base.css: --step-2 (25-28px responsive) */
    font-size: var(--step-2);
    font-weight: 600;
    margin-block: var(--space-m-l) var(--space-s-m); /* Fluid spacing */
  }

  .portable-text h4 {
    /* Aligned with base.css: --step-1 (20-23px responsive) */
    font-size: var(--step-1);
    font-weight: 600;
    margin-block: var(--space-s-m) var(--space-xs-s); /* Fluid spacing */
  }
  
  .portable-text p {
    margin-block: var(--space-m); /* Fluid spacing */
  }

  .portable-text blockquote {
    border-left: 4px solid #e5e5e5;
    padding-left: var(--space-m); /* Fluid spacing */
    margin-block: var(--space-m-l); /* Fluid spacing */
    font-style: italic;
  }

  .portable-text ul,
  .portable-text ol {
    margin-block: var(--space-m); /* Fluid spacing */
    padding-left: var(--space-m-l); /* Fluid spacing */
  }
  
  .portable-text li {
    margin: 0.5rem 0;
  }
  
  .portable-text code {
    background: #f5f5f5;
    padding: 0.2rem 0.4rem;
    font-family: 'Courier New', monospace;
    font-size: 0.9em;
  }
  
  .portable-text strong {
    font-weight: 600;
  }
  
  .portable-text em {
    font-style: italic;
  }
</style> 