---
/**
 * Image - Responsive Sanity image with optimized delivery
 *
 * Renders optimized images from Sanity with:
 * - Responsive srcset for different viewport sizes
 * - LQIP (Low Quality Image Placeholder) blur-up effect
 * - Aspect ratio preservation via CSS
 * - Automatic format negotiation (AVIF/WebP/JPG via Sanity CDN)
 * - Height constraint on desktop to prevent excessive scroll
 *
 * Accepts two prop structures:
 * - Direct: { image, alt, caption, credit, ... }
 * - ImageComponent (from CMS): { image: { image, alt, caption, credit } }
 *
 * @see docs/MEDIA.md - Image optimization strategy
 * @see src/lib/sanityImage.ts - Image URL generation utilities
 */

import type { SanityImageSource } from "@sanity/image-url/lib/types/types";
import { stegaClean } from '@sanity/client/stega';
import {
  getResponsiveImageSet,
  extractImageMetadata,
  getLQIPUrl,
  getOptimizedImageUrl,
  IMAGE_QUALITY,
  type ImageMetadata
} from '../lib/sanityImage';

/** Direct props structure (when component is used directly) */
interface DirectImageProps {
  image: SanityImageSource;
  alt: string;
  caption?: string;
  credit?: string;
  alignment?: 'left' | 'center' | 'right';
  size?: 'small' | 'medium' | 'large' | 'full';
  aspectRatio?: '4:5' | '1:1' | '16:9' | '9:16' | number;
  className?: string;
  loading?: 'lazy' | 'eager';
  quality?: number;
  formats?: string[];
  sizes?: string;
  placeholder?: 'blur' | 'color' | 'empty';
  priority?: boolean;
  _key?: string;
  _type?: string;
}

// ImageComponent structure (from Sanity CMS)
interface ImageComponentProps {
  image: {
    image: SanityImageSource;
    alt?: string;
    caption?: string;
    credit?: string;
  };
  aspectRatio?: '4:5' | '1:1' | '16:9' | '9:16' | number;
  size?: 'small' | 'medium' | 'large' | 'full';
  alignment?: 'left' | 'center' | 'right';
  _key?: string;
  _type?: string;
}

type Props = DirectImageProps | ImageComponentProps;

// Type guard to check if props is ImageComponent structure
function isImageComponent(props: Props): props is ImageComponentProps {
  return 'image' in props &&
         props.image !== null &&
         typeof props.image === 'object' &&
         'image' in props.image;
}

// Extract props with type safety
const props = Astro.props;
const image = isImageComponent(props) ? props.image.image : props.image;
const alt = isImageComponent(props) ? (props.image.alt || '') : props.alt;
const caption = isImageComponent(props) ? props.image.caption : props.caption;
const credit = isImageComponent(props) ? props.image.credit : props.credit;
const alignment = props.alignment || 'center';
const size = props.size || 'medium';
const aspectRatio = stegaClean(props.aspectRatio) || '4:5';
const className = 'className' in props ? props.className || '' : '';
const loading = 'loading' in props ? props.loading || 'lazy' : 'lazy';
const quality = 'quality' in props ? props.quality || IMAGE_QUALITY.CARD : IMAGE_QUALITY.CARD;
const sizes = 'sizes' in props ? props.sizes : undefined;
const placeholder = 'placeholder' in props ? props.placeholder || 'blur' : 'blur';
const priority = 'priority' in props ? props.priority || false : false;
const _key = props._key;
const _type = props._type;

// Convert aspect ratio to numeric value
const getAspectRatioValue = (ratio: string | number): number => {
  if (typeof ratio === 'number') return ratio;
  const [width, height] = ratio.split(':').map(Number);
  return width / height; // Changed: width/height instead of height/width for CSS aspect-ratio
};

const aspectValue = getAspectRatioValue(aspectRatio);

// Max height for images on desktop (~600px, matches CSS max-block-size)
// CSS uses calc(var(--space-3xl) * 7.5) which ranges 480-600px
// We use the maximum to ensure crisp images at all viewport sizes
const MAX_IMAGE_HEIGHT = 600;

// Map size prop to actual display width (matching ch-based widths)
const getDisplayWidth = (size: string): number => {
  switch (size) {
    case 'small': return 320;   // ~40ch (extra-narrow)
    case 'medium': return 600;  // ~55ch (media-narrow)
    case 'large': return 800;   // ~65ch (narrow)
    case 'full': return 1200;   // ~100ch (base)
    default: return 600;
  }
};

// Define responsive breakpoints based on size
const getImageWidths = (size: string): number[] => {
  switch (size) {
    case 'small': return [300, 400, 600];
    case 'medium': return [400, 600, 800, 1200];
    case 'large': return [600, 800, 1200, 1600];
    case 'full': return [800, 1200, 1600, 2000];
    default: return [400, 600, 800, 1200];
  }
};

// Generate automatic sizes attribute if not provided
const getAutoSizes = (size: string): string => {
  switch (size) {
    case 'small': return '(max-width: 768px) 100vw, 300px';
    case 'medium': return '(max-width: 768px) 100vw, 600px';
    case 'large': return '(max-width: 768px) 100vw, 800px';
    case 'full': return '100vw';
    default: return '(max-width: 768px) 100vw, 600px';
  }
};

// Generate optimized widths based on actual displayed dimensions for ALL images
const getOptimizedWidths = (baseWidth: number, aspectVal: number, maxHeight: number): number[] => {
  const naturalHeight = baseWidth / aspectVal;

  // Determine actual displayed width (accounting for max-height constraint)
  const actualWidth = naturalHeight > maxHeight
    ? Math.round(maxHeight * aspectVal)
    : baseWidth;

  // Generate widths: 0.5x, 0.75x, 1x, 1.5x, 2x of actual displayed width
  const multipliers = [0.5, 0.75, 1, 1.5, 2];
  return multipliers
    .map(m => Math.round(actualWidth * m))
    .filter(w => w >= 200 && w <= 2400); // Reasonable bounds
};

const imageWidths = getOptimizedWidths(getDisplayWidth(size), aspectValue, MAX_IMAGE_HEIGHT);
const imageSizes = sizes || getAutoSizes(size);

// Generate responsive srcset with auto-format (only if image exists)
// Uses Sanity CDN content negotiation for AVIF/WebP/JPG
const responsiveSrcset: string = image ? getResponsiveImageSet(
  image,
  imageWidths,
  aspectValue,
  quality
) : '';

// Extract metadata for advanced features
const metadata: ImageMetadata = image ? extractImageMetadata(image) : {};

// Generate LQIP placeholder for blur-up effect
let placeholderUrl: string | null = null;
if (image && placeholder === 'blur') {
  placeholderUrl = metadata.lqip || getLQIPUrl(image);
}

// Calculate dimensions accounting for max-height constraint
const displayWidth = getDisplayWidth(size);
const naturalHeight = Math.round(displayWidth / aspectValue);

// If height would exceed max, calculate from max height instead
let imageWidth: number;
let imageHeight: number;

if (naturalHeight > MAX_IMAGE_HEIGHT) {
  // Tall image: calculate from max height to request optimal size
  imageHeight = MAX_IMAGE_HEIGHT;
  imageWidth = Math.round(MAX_IMAGE_HEIGHT * aspectValue);
} else {
  // Normal image: calculate from width
  imageWidth = displayWidth;
  imageHeight = naturalHeight;
}

// Generate fallback URL with fixed height and calculated width (only if image exists)
const fallbackUrl = image ? getOptimizedImageUrl(
  image,
  imageWidth,
  imageHeight,
  quality
) : null;

// Determine loading strategy
const imageLoading = priority ? 'eager' : loading;
const fetchPriority = priority ? 'high' : 'auto';

---

<figure
  class={`image-container image-${alignment} image-${size} ${className}`}
  data-sanity={_key ? `${_type}.${_key}` : _type}
>
  {image ? (
    <img
      src={fallbackUrl || ''}
      srcset={responsiveSrcset}
      alt={alt}
      width={imageWidth}
      height={imageHeight}
      loading={imageLoading}
      decoding="async"
      fetchpriority={fetchPriority}
      sizes={imageSizes}
      class="image"
      style={`aspect-ratio: ${aspectValue}; ${placeholderUrl ? `background-image: url(${placeholderUrl}); background-size: cover; background-position: center;` : 'background-color: var(--color-gray-100, #f5f5f5);'}`}
    />
  ) : (
    <div class="image-missing">
      <span>Bilde ikke tilgjengelig</span>
    </div>
  )}

  {(caption || credit) && (
    <figcaption class="image-caption">
      {caption && <span class="caption-text">{caption}</span>}
      {credit && <small class="credit-text">{credit}</small>}
    </figcaption>
  )}
</figure>

<style>
  /* CSS Variable-based width control - Kevin Powell method */
  .image-container {
    position: relative;
    overflow: hidden;
    width: fit-content; /* Wrap tightly around image */
    max-width: 100%;
    margin-block: var(--space-l); /* Fluid 24px → 30px */
    content-visibility: auto; /* Performance: render only when visible */
  }

  /* Alignment controls container positioning */
  .image-container.image-left {
    margin-inline: 0 auto;
  }

  .image-container.image-center {
    margin-inline: auto;
  }

  .image-container.image-right {
    margin-inline: auto 0;
  }

  /* When inside a layout context, fill parent space instead of fixed dimensions */
  :global([data-layout-context]) .image-container {
    width: 100%;
    height: 100%;
    margin: 0;
  }

  :global([data-layout-context]) .image {
    width: 100%;
    height: 100%;
  }

  /* Image element with LQIP background placeholder */
  .image {
    display: block;
    width: 100%;
    height: auto; /* Let aspect-ratio control height */
    object-fit: cover;
    object-position: center;

    /* aspect-ratio set via inline style (from component props) */
    /* Placeholder shows as background during load */
    /* background-image and background-color set via inline style */
  }

  /* Limit tall images on desktop to prevent excessive scroll */
  @media (min-width: 48rem) {
    .image {
      max-block-size: calc(var(--space-3xl) * 7.5); /* ~480-600px fluid */
    }
  }

  /* Caption styling */
  .image-caption {
    margin-top: 0.5rem;
    font-size: var(--step--1); /* 15px → 18px - fluid captions & labels */
  }

  .caption-text {
    display: block;
  }

  .credit-text {
    display: block;
    margin-top: 0.25rem;
  }

  /* Missing image placeholder */
  .image-missing {
    background: #f5f5f5;
    border: 2px dashed #ddd;
    padding: var(--space-l); /* Fluid 24px → 30px */
    text-align: center;
    aspect-ratio: 4/5;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  @media (prefers-color-scheme: dark) {
    .image-missing {
      background: #2a2a2a;
      border-color: #444;
      color: #aaa;
    }
  }
</style>
