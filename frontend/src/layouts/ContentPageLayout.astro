---
import Layout from './Layout.astro';
import DynamicComponent from '../components/DynamicComponent.astro';
import { getMultilingualContent, detectLanguage, type BilingualDocument } from '../lib/utils/language.js';
import { stegaClean } from '@sanity/client/stega';
import type { PageBuilder } from '../../sanity/sanity.types';

interface SeoData {
  title?: string;
  description?: string;
  indexingStatus?: 'index' | 'noindex';
}

interface PageDocument extends BilingualDocument {
  _id?: string;
  content?: PageBuilder;
  seo?: SeoData;
  image?: any;
}

interface Props {
  title: string;
  excerpt?: string;
  pageContent?: PageBuilder;
  pageDocument?: PageDocument;
  /** SEO data override (uses pageDocument.seo by default) */
  seo?: SeoData;
  /** Image for OG/Twitter cards (uses pageDocument.image by default) */
  image?: any;
  /** Page type for OG */
  ogType?: 'website' | 'article' | 'event';
}

const {
  title,
  excerpt,
  pageContent = [],
  pageDocument,
  seo,
  image,
  ogType = 'website'
} = Astro.props;

// Resolve SEO data: explicit prop > pageDocument.seo
const resolvedSeo = seo || pageDocument?.seo;
const resolvedImage = image || pageDocument?.image?.image || pageDocument?.image;

// Detect language from URL to use correct content
const language = detectLanguage(Astro.request);

// Explicit pageContent prop takes precedence, otherwise extract from document
const content = pageContent?.length
  ? pageContent
  : (pageDocument ? getMultilingualContent(pageDocument, language) : []);

// Extract slug information from pageDocument if available and clean stega encoding
const slugNo = pageDocument?.slug_no?.current ? stegaClean(pageDocument.slug_no.current) : undefined;
const slugEn = pageDocument?.slug_en?.current ? stegaClean(pageDocument.slug_en.current) : undefined;

// Clean title for browser tab (keep raw title in h1 for Visual Editing)
const cleanTitle = stegaClean(title);
---

<Layout
  title={cleanTitle}
  description={excerpt ? stegaClean(excerpt) : undefined}
  slugNo={slugNo}
  slugEn={slugEn}
  seo={resolvedSeo}
  image={resolvedImage}
  ogType={ogType}
>
  <!-- Slot for structured data (JSON-LD schemas) -->
  <slot name="structured-data" />

  <div class="stack page-layout" style="--space: var(--space-xl)">
    <header class="page-header">
      <h1 class="page-title">
        {title}
      </h1>
      {excerpt && (
        <p class="excerpt">{excerpt}</p>
      )}
    </header>

    <!-- Page content from schema -->
    {content && Array.isArray(content) && content.length > 0 && (
      <div class="stack page-content" style="--space: var(--space-l-xl)">
        {content.map((block) => (
          <DynamicComponent key={block._key || block._id} block={block} />
        ))}
      </div>
    )}

    <!-- Main content slot (for listings, etc.) -->
    <slot />
  </div>
</Layout>

<style>
  /* ============================================
     INTRINSIC CONTENT PAGE LAYOUT
     ============================================

     Uses layout primitives (center, stack) for consistent,
     intrinsic responsive behavior.

     Key features:
     - Center primitive: Max-width constraint + centering
     - Stack primitive: Vertical rhythm with fluid spacing
     - Container query support for children
     - No media queries needed
  */

  .page-layout {
    /* Enable container queries for child components */
    container-type: inline-size;
    container-name: page-layout;

    /* Ensure content doesn't get too narrow on small screens */
    min-inline-size: min(100%, 280px);
  }

  .page-header {
    margin: 0;
    container-type: inline-size; /* Enable container queries for h1 sizing */
  }

  .page-title {
    margin: 0 0 var(--space-6) 0;
    /* Use container query-based h1 token for Norwegian long words */
    font-size: var(--heading-h1); /* Fluid 37-69px with cqi sizing */
    /* Ensure title wraps gracefully with Norwegian/English text */
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
  }

  /* Excerpt styling now handled by global .excerpt class in base.css */

  /* Fallback for browsers without container query support */
  @supports not (container-type: inline-size) {
    .page-layout {
      /* Traditional max-width pattern */
      max-inline-size: var(--container-max-width);
    }

    .page-title {
      /* Viewport-based fallback when cqi is unsupported */
      font-size: clamp(1.944rem, 1.5rem + 4vw, 3.8147rem);
    }
  }
</style>